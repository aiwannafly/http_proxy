# HTTP Proxy
A simple HTTP 1.* proxy implemented in `C++` with use of `pthread` library.

Основной класс прокси-сервера находится в файле `multithread_proxy.cpp`. Архитектура очень простая, удалось сделать хорошую модульность. Классы клиента и сервера располагаются в директориях `client` и `server` соответственно.

В потоке `main` работает сам прокси, который принимает входящие соединения клиентов. Для каждого клиента создается новый поток. Клиент запрашивает ресурс у общего на все потоки объекта `CachingResourceManager`, который может либо отдать ссылку на ресурс в кэше, либо при необходимости породить серверный поток, который будет заниматься пополнением кэша и уведомлением клиентов об этом.

[![image.png](https://i.postimg.cc/3xK6tj4K/image.png)](https://postimg.cc/fJrBL9fF)

Для парсинга HTTP сообщений использовал https://github.com/nekipelov/httpparser.

Во всей программе есть только два мутекса - один для синхронизации доступа к кэшу, второй для синхронизации доступа к самому ресурсу (response, который мы получаем от сервера) при помощи `pthread_rwlock_t`.

Кэш представлен в виде класса `cache/map_cache.h`, реализующего интерфейс `cache/cache.h`. Его устройство довольно простое, он работает на `std::map`. Сам он не содержит в себе каких-то механизмов синхронизации, на себя это берет `CachingResourceManager`, что наглядно представлено в файле `resource_manager/caching_resource_manager.cpp`.

Ресурс в моей программе реализует интерфейс из файла `resource/resource.h`, его имплементация находится в файле `resource/simple_resource.h`. На ресурс можно подписаться, отписаться, узнать статус его готовности, получить актуальный список его составных кусков. Список этих кусков - **threadsafe**, синхронизация осуществляется при помощи примитива `pthread_rwlock_t`.

По поводу подписки на ресурс. Для реализации уведомлений о новых частях ресурса использовался инструмент `eventfd`, во многом напоминающий `pipe`, но превосходящий его в некоторых аспектах.
Этот объект я создаю с флагом `EFD_SEMAPHORE`, это на деле означает следующее: `read` для этого дескриптора декрементирует его внутренний счетчик на единицу, а `write` увеличивает счетчик на то значение, которое я передаем ему в аргументы. Если текущее значение счетчика равно нулю, то `read` будет блокироваться. Это позволяет мне уведомлять произвольное число клиентов о новом куске ресурса. Вся вышеизложенная логика представлена в файлах `server/server.cpp` и `client/client.cpp`. Сам объект `eventfd` создается в конструкторе ресурса из файла `resoruce/simple_resource.h`.

Также были написаны тесты, я выделил следующие 4 проверки:
  * *базовый тест* на то, что через прокси вообще сейчас можно получить хоть какие либо данные
  * скачивание файла большого размера два раза, смотрим, что второй раз скорость выше минимум в два раза
  * одновременное открытие 30 соединений на скачивание файла большого размера
  * одновременное открытие 5 сессий на скачивание файла 200MB c циклическим перезапуском соединений (для этого я выставляю разные timeout в curl)
Во всех тестах проверяется, что полученные данные совпадают с ожидаемым результатом.

Сборка как тестов, так и самого прокси, выполняется через файл `make.sh`.

Запуск как прокси, так и тестов выглядит следующим образом: `./prog <proxy_port>`.
